#! /usr/bin/env bash
version="2.0.0"

###########################################################################
# Program: SSDcronTRIM                                                    #
# Author:  Matthias Egger <m.egger@matse.ch>                              #
# Purpose: intelligent cron job script which automatically                #
#          decides how often to trim one or more SSD partitions.          #
# History: See CHANGELOG.md                                               #
# License:                                                                #
#    This program is free software: you can redistribute it and/or modify #
#    it under the terms of the GNU General Public License as published by #
#    the Free Software Foundation, either version 3 of the License, or    #
#    (at your option) any later version.                                  #
#                                                                         #
#    This program is distributed in the hope that it will be useful,      #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of       #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #
#    GNU General Public License for more details.                         #
#                                                                         #
#    You should have received a copy of the GNU General Public License    #
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.#
#                                                                         #
###########################################################################



##### [ S E T T I N G S ] #################################################

# This script assumes by default that only your root partition '/' is on an
# SSD. You can add more SSD mount points, separated by spaces. Make sure
# all mount points are within the quotes. For example:
# SSD_MOUNT_POINTS="/ /home /media/my_other_ssd"
mount_points="/"

# Normally you do not have to modify the trimmable_fs variable. It contains
# a list of available filesystems which are known to support the FITRIM call.
# The list is created by searching for FITRIM in the kernel sources.
#
# cd /usr/src/linux
# grep -lr FITRIM fs/ | cut -d/ -f2 | sort | uniq | xargs echo
trimmable_fs=("btrfs" "ecryptfs" "ext3" "ext4""f2fs" "gfs2" "jfs" "nilfs2"
    "ocfs2" "xfs")



##### [ F U N C T I O N S ] ###############################################

be_sane()
{
    # assert that we are root
    if [[ "${EUID}" != "0" ]] || [[ "${UID}" != "0" ]] ||
        [[ "${USER}" != "root" ]] || [[ "$(id -u)" != "0" ]]; then
        printf '%s\n' "Error: you must be root to run this program!"
        exit 1
    fi

    # check if we have cron
    if [[ -d /var/spool/cron ]] &&
        [[ -x /usr/bin/crontab ]] ||
        [[ -x /bin/crontab ]]; then
        have_cron=true
    else
        have_cron=false
    fi

    # assert that mount points support TRIM and disks support TRIM
    for mp in ${mount_points[*]}; do
        if [[ ! "${trimmable_fs[*]}" =~ "$(findmnt -M $mp -n -o FSTYPE)" ]]; then
            printf '%s\n' "Error: mountpoint $mp does not support TRIM."
            exit 2
        fi

        disk="$(findmnt -M $mp -n -o SOURCE)"
        disk=${disk%%[1-9]*}
        if ( ! hdparm -I "${disk}" | grep -F -q "TRIM" ); then
            printf '%s\n' "Error: the disk on $mp does not support TRIM."
            exit 3
        fi
    done
    unset mp disk

    # assert that the kernel supports TRIM
    file="$(mktemp)"
    echo "2.6.40" > "${file}"
    kernel="$(uname -r)"
    kernel=${kernel%%-*}
    echo "${kernel}" >> "${file}"
    kern="$(sort -V "${file}" | head -n1)"
    if [[ "${kern}" != "${kernel}" ]]; then
        printf '%s\n' "Error: you must be using Linux kernel >= 2.6.40."
        exit 4
    fi
    rm "${file}"
    unset file kernel kern

    # assert that we have fstrim
    if [[ -z "$(command -v fstrim)" ]]; then
        printf '%s\n' "Error: fstrim must be in $PATH to use this script."
        exit 5
    fi
}

showusage () {
clear
cat<<EOF
USAGE:

`$BASENAME $0` [-h|--help]
`$BASENAME $0` [-d|--deinstall]
`$BASENAME $0` -v

-h, --help          Show this help screen and exit
-d, --deinstall     Removes any cronjob created by `$BASENAME $0` and
                    also deletes the installed man page. To reinstall
                    `$BASENAME $0` just start it without option.
-v                  print the version of `$BASENAME $0` and exit

`$BASENAME $0` is an intelligent cronjob which, depending on the usage of
your SSD Disk(s), automatically decides how often the SSD(s) should be trimmed.
The more data you have on your SSD(s) the more often they will be trimmed.

It is intended as a fire and forget app which, once installed, does everything
fully automated. In fact it is so clever, you should be able to install it on
any linux system without using the package manager of your distribution. Just
open this script with your favorite text editor, add the partition(s) which
should be trimmed (as a space separated list into the SSD_MOUNT_POINTS
variable) and then execute `$BASENAME $0` without any option.

Beside the needed cron job(s) it also creates a man page on the fly. Both, the
cron job(s) and manual page installation does not interfere with your existing
distribution. And if you want to get rid of this script just start it with the
deinstall option and it will remove any cron job(s) and the man page.

EOF
exit 0
};

deinstall () {
	# deinstall does either a hard or soft deinstallation. The difference is,
	# that a soft deinstallation only removes the cronjob files without any
	# notification, whereas a hard deinstallation also removes the manual page
	# and does a notification about the completely deinstalled SSDcronTRIM.
	[ ! -z $1 ] && SOFT="true"
	
	if [ -z $SOFT ]; then
		# Hard deletion = remove man page
		for mpath in /usr/share/man /usr/local/share/man /usr/man;do
			fpath=${mpath}/man1/SSDcronTRIM.1
			[ -f ${fpath} ] && { rm ${fpath}; echo "SSDcronTRIM man page ($fpath) removed."; break; }
		done
	fi

	if [ "$ctool" == "crondirs" ];then
		for dir in monthly weekly daily hourly;do
			$FIND /etc/cron.${dir} -nowarn -name "SSDcronTRIM_part-*" -type f -print
		done|xargs rm -f
	else
		epath="`${MKTEMP} -p /tmp SSDcronTRIMcrontabEDIT.XXXXXXXXXX`"
		${ctool} -l | $GREP -v SSDcronTRIM_part > ${epath}
		${ctool} ${epath}
		rm ${epath}
		rm -f ${CRONTAB_DIR}/SSDcronTRIM_part-*
	fi

	if [ -z $SOFT ]; then
		echo "All SSDcronTRIM cron jobs removed."
	fi
}

create_man () {
	# create_man does first a check if the man page still exists. It will
	# create the man page otherwise. Overgive the path to the file which
	# should be created.
	newfpath=$1

	if [ ! -f $newfpath ]; then
cat<<EOF >$newfpath
.\" Manpage for SSDcronTRIM.
.\" Contact m.egger@matse.ch to correct errors or typos.
.TH SSDcronTRIM "1" "February 2016" "1.04" "SSDcronTRIM man page"
.SH NAME
SSDcronTRIM \- Intelligent SSD cron job which decides when to TRIM
.SH SYNOPSIS
.B SSDcronTRIM
[\fIOPTION\fR]
.SH DESCRIPTION
.\" Add any additional description here
.PP
SSDcronTRIM is an intelligent cronjob which, depending on the usage of
your SSD Disk(s), automatically decides how often the SSD(s) should be trimmed.
The more data you have on your SSD(s) the more often they will be trimmed. The
trim ratio is defined as follows:
.PP
.BD -literal
 \.\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\.\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\.
 | Used space in % | Amount of trims |
 |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
 |   85% \- 100%    |     Hourly      |
 |   60% \-  84%    |     Daily       |
 |   31% \-  59%    |     Weekly      |
 |    0% \-  30%    |     Monthly     |
 \\\`\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\^\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\'
.ED
.PP
SSDcronTRIM is intended as a \fIfire and forget\fR app which, once installed, does
everything fully automated. In fact it is so clever, you should be able to
install it on any linux system without using the package manager of your
distribution.
.PP
Just open the SSDcronTRIM script with your favorite text editor, add the
partition(s) which should be trimmed (as a space separated list into the
SSD_MOUNT_POINTS variable) and then execute SSDcronTRIM without any option.
.PP
To trimm a partition SSDcronTRIM uses the \fBfstrim\fR command, which should
be installed on any modern system, since it is part of the \fButil\-linux\fR
package.
.SH OPTIONS
.PP
SSDcronTRIM does not need any option to work. Just start it once and it will
install itself as one or more cronjob(s) (depending on how many SSD partitions
have to be trimmed). Nevertheless it understands the following options.
.TP
\fB\-d\fR, \fB\-\-deinstall\fR
Use the deinstall option to remove all cron jobs which have been created by
SSDcronTRIM and to delete this man page. This is something like a self
desctruction option. If you have not created a backup of SSDcronTRIM you have
to re-download and re-add your settings again.
.TP
\fB\-h\fR, \fB\-\-help\fR
Show a summary of this man page.
.TP
\fB\-v\fR
print the version of SSDcronTRIM and exit
.SH SEE ALSO
fstrim(8)
.SH BUGS
No known bugs.
.SH AUTHOR
Matthias Egger <m.egger@matse.ch>
EOF
	fi
}

CreateCron () {
	# CreateCron creates the cronfiles and if necessary also the crontab entry.
	# USAGE: CreateCron "monthly|weekly|daily|hourly" "<mountpoint>" "dir|/some/path/for/cronfiles"
	ctype="$1"
	mop="$2"
	ipath="$3"

	# First we need to replace all / in the pathes with _slash_
	mpstripped="`echo $mop|$SED -e 's#/#_slash_#g' -e 's/ /_space_/g'`"

	# Now install the script
	if [ "$ipath" == "dir" ];then
		# Install it into /etc/cron.{monthly,weekly,daily,hourly}
		cp $MEIMYSELF "/etc/cron.${ctype}/SSDcronTRIM_part-${mpstripped}"
		chmod 740 "/etc/cron.${ctype}/SSDcronTRIM_part-${mpstripped}"
	else
		# Install it to some path and edit crontab
		cp $MEIMYSELF "${ipath}/SSDcronTRIM_part-${mpstripped}"
		chmod 740 "${ipath}/SSDcronTRIM_part-${mpstripped}"
		epath="`${MKTEMP} -p /tmp SSDcronTRIMcrontabEDIT.XXXXXXXXXX`"
		${ctool} -l > ${epath}
		if [ "$ctype" == "monthly" ];then
			echo "0 0 1 * * ${ipath}/SSDcronTRIM_part-${mpstripped}" >> ${epath}
		elif [ "$ctype" == "weekly" ]; then
			echo "0 0 * * 0 ${ipath}/SSDcronTRIM_part-${mpstripped}" >> ${epath}
		elif [ "$ctype" == "daily" ]; then
			echo "0 0 * * * ${ipath}/SSDcronTRIM_part-${mpstripped}" >> ${epath}
		elif [ "$ctype" == "hourly" ]; then
			echo "0 * * * * ${ipath}/SSDcronTRIM_part-${mpstripped}" >> ${epath}
		fi
		${ctool} ${epath}
		rm ${epath}
	fi
}

##### [ M A I N ] #########################################################

# Just make sure we can exit from Subshells. Whenever we send from within a
# function a TERM signal to the TOPLEVEL PID, this gets caught (by trap) and
# finally exits this program.
trap "exit 1" TERM
export TOP_PID=$$

# Check if some elementary system tools are available
find_tool tr; TR=$TOOL
find_tool cut; CUT=$TOOL
find_tool mount; MOUNT=$TOOL
find_tool uname; UNAME=$TOOL
find_tool sed; SED=$TOOL
find_tool find; FIND=$TOOL
find_tool grep; GREP=$TOOL
find_tool df; DF=$TOOL
find_tool basename; BASENAME=$TOOL
find_tool mktemp; MKTEMP=$TOOL

# Was this script started with any option?
if [ ! -z $1 ]; then
	if [ "$1" == "-h" ] || [ "$1" == "--help" ];then
		showusage
	fi
	if [ "$1" == "-v" ];then
		echo "`$BASENAME $0` - Version $version"
		exit 0
	fi
	if [ "$1" == "-d" ] || [ "$1" == "--deinstall" ];then
		DEINSTALL="true"
	fi
	[ -z $DEINSTALL ] && showusage
fi

# Since we always remove the cronjob files, we need to make a temporary backup
# of this file. Otherwise we would remove ourself :-(
MEIMYSELF="`${MKTEMP} -p /tmp SSDcronTRIMcrontabEDIT.XXXXXXXXXX`"
MYNAME=`$BASENAME $0`
cp $0 $MEIMYSELF

# Check if mandatory settings (like Kernel with TRIM support etc.) are (still) available.
STATE=`init_check`
ruser="`echo $STATE|cut -d: -f1`"; ctool="`echo $STATE|cut -d: -f2`"; fsmnt="`echo $STATE|cut -d: -f3`"
hwsup="`echo $STATE|cut -d: -f4`"; krnls="`echo $STATE|cut -d: -f5`"; FSTRIM="`echo $STATE|cut -d: -f6`"
if [ "$ruser" == "nonroot" ] || [ "$ctool" == "nocron" ] || [ ! "$fsmnt" == "supported" ] ||
   [ ! "$hwsup" == "hwtrim" ] || [ "$krnls" == "NOkernelTRIM" ] || [ "$FSTRIM" == "noFSTRIM" ]; then
	echo "ERROR Report for $0"
	echo -en '----------------------------------------------------------------------\n'
	MSG=""
	if [ "$ruser" == "nonroot" ]; then
	  MSG="${MSG}\nERROR: Please start this script only as root, since this tool has to\n"
	  MSG="${MSG}ERROR: access filesystems and cronjobs directly (which can't be done as\n"
	  MSG="${MSG}ERROR: a regular user).\n"
	fi
	if [ "$ctool" == "nocron" ]; then
	  MSG="${MSG}\nERROR: Well, this tool does most of it's magic as a cron job. But on\n"
	  MSG="${MSG}ERROR: this system there was no /etc/cron.{monthly,weekly,daily,hourly}\n"
	  MSG="${MSG}ERROR: directory nor a crontab executable.\n"
	fi
	if [ ! "$fsmnt" == "supported" ]; then
	  MSG="${MSG}\nERROR: You have specified $fsmnt in SSD_MOUNT_POINTS but\n"
	  MSG="${MSG}ERROR: either the partition was not mounted (fstrim only works on\n"
	  MSG="${MSG}ERROR: mounted partitions) or its filesystem does not support the FITRIM\n"
	  MSG="${MSG}ERROR: Feature. Currently this Feature is only supported by the following\n"
	  MSG="${MSG}ERROR: filesystems: `echo ${TRIMMABLE_FS}|$TR , ' '`\n"
	fi
	if [ ! "$hwsup" == "hwtrim" ]; then
	  MSG="${MSG}\nERROR: You have specified $hwsup in SSD_MOUNT_POINTS but\n"
	  MSG="${MSG}ERROR: it looks like the disk itself does not support any TRIMMING.\n"
	  MSG="${MSG}ERROR: Is the disk really an SSD Disk?\n"
	fi
	if [ "$krnls" == "NOkernelTRIM" ]; then
	  MSG="${MSG}\nERROR: Your Kernel (`uname -r`) does not support FITRIM. Please make\n"
	  MSG="${MSG}ERROR: sure you use at least an 2.6.40 kernel.\n"
	fi
	if [ "$FSTRIM" == "noFSTRIM" ]; then
	  MSG="${MSG}\nERROR: Sorry, but i could not locate the fstrim tool on this system.\n"
	  MSG="${MSG}ERROR: Usually it can be found as part of the util-linux or util-linux-ng\n"
	  MSG="${MSG}ERROR: package and should be installed on any modern Linux system.\n"
	fi

	echo -e "$MSG"
	echo -en '----------------------------------------------------------------------\n'
	exit 1
fi

# Finally we can de-/install or use this script.
if [ -z $DEINSTALL ]; then
	# First we remove any installed cronjobs. Since the last TRIM could have been
	# last month, the SSD could have be filled with lots of data. Therefore we just
	# remove any cronjob and then reinstall them later.
	deinstall soft

	# Get the Mountpoint we should trim later
	MP="`echo $MYNAME|$SED -e 's#_slash_#/#g' -e 's/_space_/ /g' -e 's/^SSDcronTRIM_part-//g'`"
	NewOrOld=0

	for part in $SSD_MOUNT_POINTS;do
		# How many percent of space is used on this disk?
		partusage=`$DF $part|$GREP "$part"|$TR -s [:blank:]|$CUT -d' ' -f5|$CUT -d% -f1`

		# Try to install the SSDcronTRIM man page
		for mpath in /usr/share/man /usr/local/share/man /usr/man;do
			fpath=${mpath}/man1/SSDcronTRIM.1
			[ -d ${mpath}/man1 ] && { create_man ${fpath}; break; }
		done

		if [ "$ctool" == "crondirs" ];then
			# Install this script to /etc/cron.{daily,hourly,monthly,weekly}
			DTYPE="dir"
		else
			# We use crontab, so install the script into $CRONTAB_DIR
			DTYPE="${CRONTAB_DIR}"
		fi

		# Now create the cron job
		if [ $partusage -le 30 ]; then
			CreateCron "monthly" "${part}" "$DTYPE"
		elif [ $partusage -ge 31 ] && [ $partusage -le 59 ]; then
			CreateCron "weekly" "${part}" "$DTYPE"
		elif [ $partusage -ge 60 ] && [ $partusage -le 84 ]; then
			CreateCron "daily" "${part}" "$DTYPE"
		elif [ $partusage -ge 85 ]; then
			CreateCron "hourly" "${part}" "$DTYPE"
		fi

		# Is this a fresh installation or just an initiated cronjob?
		[ "${MP}" == "$part" ] && NewOrOld=1
		
	done

	# Now the most important part; Let us trim (if this is not a fresh installation)!
	if [ $NewOrOld -eq 1 ]; then
		${FSTRIM} $MP
	else
		echo "SSDcronTRIM successfully installed for these Mountpoints: $SSD_MOUNT_POINTS"
		if [ "$ctool" == "crondirs" ];then
			echo "Look into /etc/cron.{monthly,weekly,daily,hourly} for instances of this script"
		else
			echo "Look into ${CRONTAB_DIR} for instances of this script"
			echo "and also check the installation with crontab -l"
		fi
	fi
else
	deinstall
fi

# Cleanup
rm $MEIMYSELF

exit
